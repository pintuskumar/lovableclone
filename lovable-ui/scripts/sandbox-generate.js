const OpenAI = require("openai");
const fs = require("fs");

const DEFAULT_AI_GATEWAY_MODEL = "anthropic/claude-sonnet-4.5";
const AI_GATEWAY_MODEL =
  process.env.AI_GATEWAY_MODEL || DEFAULT_AI_GATEWAY_MODEL;

// Initialize OpenAI client for Vercel AI Gateway (OpenAI-compatible API)
const aiClient = new OpenAI({
  apiKey: process.env.VERCEL_AI_GATEWAY_API_KEY,
  baseURL: "https://ai-gateway.vercel.sh/v1",
});

// Essential files that must exist for a Next.js project to work
const ESSENTIAL_FILES = {
  "tsconfig.json": `{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}`,
  "postcss.config.js": `/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

module.exports = config;`,
  "next.config.js": `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
};

module.exports = nextConfig;`,
  "tailwind.config.js": `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [require('@tailwindcss/typography')],
};`,
  "app/globals.css": `@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-rgb: 10, 10, 10;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}`,
  "next-env.d.ts": `/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.`,
};

// Function to sanitize CSS content - remove unsupported Tailwind classes
function sanitizeCssContent(cssContent) {
  // Remove @apply rules that use prose classes if typography plugin might not be installed
  // Instead of removing, we'll keep them but ensure the plugin is installed

  // Remove any @apply rules with classes that commonly cause issues
  const problematicPatterns = [
    // Remove @apply with prose if it appears without proper setup
    // Actually, we'll install the typography plugin, so just clean up malformed CSS
  ];

  let sanitized = cssContent;

  // Fix common CSS issues
  // Remove empty @apply rules
  sanitized = sanitized.replace(/@apply\s*;/g, "");

  // Remove @apply rules that only have whitespace
  sanitized = sanitized.replace(/@apply\s+;/g, "");

  return sanitized;
}

// Fallback package.json if AI doesn't generate one
const FALLBACK_PACKAGE_JSON = {
  name: "generated-website",
  version: "0.1.0",
  private: true,
  scripts: {
    dev: "next dev",
    build: "next build",
    start: "next start",
    lint: "next lint",
  },
  dependencies: {
    next: "14.2.3",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
  },
  devDependencies: {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@tailwindcss/typography": "^0.5.13",
    autoprefixer: "^10.4.19",
    postcss: "^8.4.38",
    tailwindcss: "^3.4.3",
    typescript: "^5",
  },
};

// Fallback layout if AI doesn't generate one or it has import issues
const FALLBACK_LAYOUT = `import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Generated Website',
  description: 'Generated by AI',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}`;

// Fallback page if AI doesn't generate one
const FALLBACK_PAGE = `export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <h1 className="text-4xl font-bold mb-4">Welcome</h1>
      <p className="text-lg text-gray-600">Your website is being set up...</p>
    </main>
  )
}`;

async function generateWebsite() {
  const prompt = process.env.USER_PROMPT || "Create a modern blog website";

  console.log(
    `Starting website generation with Vercel AI Gateway (model: ${AI_GATEWAY_MODEL})...`,
  );
  console.log("Working directory:", process.cwd());
  console.log("Prompt:", prompt);

  try {
    const response = await aiClient.chat.completions.create({
      model: AI_GATEWAY_MODEL,
      messages: [
        {
          role: "system",
          content: `You are an expert web developer. Generate complete, production-ready code for the requested website.

CRITICAL FORMATTING: Format each file with a clear path indicator EXACTLY like this:
**path/to/file.tsx**
\`\`\`typescript
// file content here
\`\`\`

CRITICAL REQUIREMENTS:
1. Create a NextJS 14 app with TypeScript and Tailwind CSS
2. Use React 18 (use "react": "^18.2.0" and "react-dom": "^18.2.0" in package.json)
3. Use the App Router (app directory structure)
4. DO NOT import components that don't exist - only import what you create
5. Keep the layout.tsx simple - DO NOT import Header/Footer components unless you fully implement them
6. If you create components, put them in the components/ directory

ROUTING RULES (VERY IMPORTANT):
- For EVERY link in your code (e.g., href="/blog"), you MUST create the corresponding page file
- Next.js App Router uses folder-based routing:
  - /blog -> app/blog/page.tsx
  - /about -> app/about/page.tsx
  - /contact -> app/contact/page.tsx
- DO NOT create links to pages you haven't implemented
- If you add a navigation link, CREATE THE PAGE FILE for it
- Use Link from 'next/link' for internal navigation

REQUIRED FILES (generate all of these):
- package.json (with all dependencies including tailwindcss, postcss, autoprefixer)
- app/layout.tsx (keep imports minimal - just globals.css and fonts)
- app/page.tsx (main page)
- app/globals.css (with @tailwind directives)

FOR EVERY LINK IN YOUR CODE:
- If you link to /blog, create app/blog/page.tsx
- If you link to /about, create app/about/page.tsx
- If you link to /contact, create app/contact/page.tsx
- And so on for ANY other routes

OPTIONAL FILES (only if needed):
- Additional pages in app/ directory (REQUIRED if you link to them!)
- Components in components/ directory (only if you import them)
- Utility files in lib/ directory

IMPORTANT:
- The layout.tsx should be self-contained. Do NOT import Header or Footer components unless you also provide their complete implementation files.
- EVERY navigation link MUST have a corresponding page file.`,
        },
        {
          role: "user",
          content: prompt,
        },
      ],
      temperature: 0.2,
      max_tokens: 8192,
    });

    const content = response.choices[0]?.message?.content || "";
    console.log("AI Response received, length:", content.length);
    console.log(
      "__AI_MESSAGE__",
      JSON.stringify({
        type: "assistant",
        content: content.substring(0, 200) + "...",
      }),
    );

    // Parse and write files from the response
    console.log("\nParsing generated code...");

    // Split by code block markers (triple backticks)
    const parts = content.split("```");
    const files = [];
    const filePathsFound = new Set();

    for (let i = 1; i < parts.length; i += 2) {
      const codeBlock = parts[i];
      const beforeBlock = parts[i - 1] || "";

      // Get code content (skip language identifier on first line)
      const lines = codeBlock.split("\n");
      const firstLine = lines[0].trim();
      const isLangId =
        /^(typescript|tsx|javascript|jsx|json|css|html|md|markdown|ts|js|mjs|cjs)$/i.test(
          firstLine,
        );
      const codeContent = isLangId ? lines.slice(1).join("\n") : codeBlock;

      // Find file path from context before code block
      const contextLines = beforeBlock.split("\n").slice(-15);
      let filePath = null;

      for (const line of contextLines.reverse()) {
        // Match: **filename.ts** or `filename.ts` or filename.ts: or // File: filename.ts
        const patterns = [
          /\*\*([\w\-\/\.]+\.[a-z]+)\*\*/,
          /`([\w\-\/\.]+\.[a-z]+)`/,
          /(?:\/\/|#)\s*(?:File:|Path:)?\s*([\w\-\/\.]+\.[a-z]+)/i,
          /^\s*([\w\-\/\.]+\.[a-z]+):?\s*$/,
          /(?:Create|File|file)\s+([\w\-\/\.]+\.[a-z]+)/i,
          /^\d+\.\s+\*?\*?([\w\-\/\.]+\.[a-z]+)\*?\*?/,
          /^###?\s+\d*\.?\s*\`?([\w\-\/\.]+\.[a-z]+)\`?/,
        ];
        for (const p of patterns) {
          const m = line.match(p);
          if (m) {
            filePath = m[1];
            break;
          }
        }
        if (filePath) break;
      }

      // Infer from content if no path found
      if (!filePath && codeContent.trim()) {
        if (
          codeContent.includes('"name"') &&
          codeContent.includes('"dependencies"')
        ) {
          filePath = "package.json";
        } else if (
          codeContent.includes("nextConfig") ||
          codeContent.includes("NextConfig")
        ) {
          filePath = "next.config.js";
        } else if (
          codeContent.includes("tailwind") &&
          codeContent.includes("content:")
        ) {
          filePath = "tailwind.config.js";
        } else if (
          codeContent.includes("RootLayout") &&
          codeContent.includes("children")
        ) {
          filePath = "app/layout.tsx";
        } else if (codeContent.includes("@tailwind")) {
          filePath = "app/globals.css";
        } else if (
          codeContent.includes("postcss") ||
          codeContent.includes("autoprefixer")
        ) {
          filePath = "postcss.config.js";
        } else if (codeContent.includes('"compilerOptions"')) {
          filePath = "tsconfig.json";
        }
      }

      if (filePath) {
        filePath = filePath.replace(/^\.?\//, "");
        // Only add if we haven't seen this file yet (avoid duplicates)
        if (!filePathsFound.has(filePath)) {
          filePathsFound.add(filePath);
          files.push({ path: filePath, content: codeContent.trim() });
          console.log("Found:", filePath);
        } else {
          console.log("Skipped duplicate:", filePath);
        }
      } else if (codeContent.trim().length > 20) {
        console.log(
          "Skipped block (no path):",
          codeContent.substring(0, 40).replace(/\n/g, " ") + "...",
        );
      }
    }

    // STEP 1: Write essential config files FIRST (these are required for Next.js to work)
    console.log("\nWriting essential config files first...");

    // Always write tsconfig.json - this is critical for @ path alias
    const tsconfigPath = "tsconfig.json";
    fs.writeFileSync(tsconfigPath, ESSENTIAL_FILES["tsconfig.json"]);
    console.log("Created essential:", tsconfigPath);

    // Always write next-env.d.ts
    const nextEnvPath = "next-env.d.ts";
    fs.writeFileSync(nextEnvPath, ESSENTIAL_FILES["next-env.d.ts"]);
    console.log("Created essential:", nextEnvPath);

    // Write postcss.config.js if not generated by AI
    if (!filePathsFound.has("postcss.config.js")) {
      fs.writeFileSync(
        "postcss.config.js",
        ESSENTIAL_FILES["postcss.config.js"],
      );
      console.log("Created essential: postcss.config.js");
    }

    // Write next.config.js if not generated by AI
    if (!filePathsFound.has("next.config.js")) {
      fs.writeFileSync("next.config.js", ESSENTIAL_FILES["next.config.js"]);
      console.log("Created essential: next.config.js");
    }

    // Write tailwind.config.js - ALWAYS overwrite to ensure typography plugin is included
    fs.writeFileSync(
      "tailwind.config.js",
      ESSENTIAL_FILES["tailwind.config.js"],
    );
    console.log(
      "Created essential: tailwind.config.js (with typography plugin)",
    );

    // STEP 2: Process package.json - ensure it has all required dependencies
    let pkgFile = files.find((f) => f.path === "package.json");
    if (!pkgFile) {
      pkgFile = {
        path: "package.json",
        content: JSON.stringify(FALLBACK_PACKAGE_JSON, null, 2),
      };
      files.push(pkgFile);
      console.log("Added fallback package.json");
    } else {
      try {
        const pkg = JSON.parse(pkgFile.content);
        // Ensure scripts exist
        if (!pkg.scripts) pkg.scripts = FALLBACK_PACKAGE_JSON.scripts;
        // Ensure required dependencies
        if (!pkg.dependencies) pkg.dependencies = {};
        if (!pkg.devDependencies) pkg.devDependencies = {};

        // Force React 18
        pkg.dependencies.react = "^18.2.0";
        pkg.dependencies["react-dom"] = "^18.2.0";

        // Ensure Next.js
        if (!pkg.dependencies.next) pkg.dependencies.next = "14.2.3";

        // Ensure Tailwind deps
        if (!pkg.devDependencies.tailwindcss)
          pkg.devDependencies.tailwindcss = "^3.4.3";
        if (!pkg.devDependencies.postcss)
          pkg.devDependencies.postcss = "^8.4.38";
        if (!pkg.devDependencies.autoprefixer)
          pkg.devDependencies.autoprefixer = "^10.4.19";
        if (!pkg.devDependencies.typescript)
          pkg.devDependencies.typescript = "^5";
        // Add typography plugin for prose classes
        if (!pkg.devDependencies["@tailwindcss/typography"])
          pkg.devDependencies["@tailwindcss/typography"] = "^0.5.13";
        if (!pkg.devDependencies["@types/node"])
          pkg.devDependencies["@types/node"] = "^20";
        if (!pkg.devDependencies["@types/react"])
          pkg.devDependencies["@types/react"] = "^18";
        if (!pkg.devDependencies["@types/react-dom"])
          pkg.devDependencies["@types/react-dom"] = "^18";

        pkgFile.content = JSON.stringify(pkg, null, 2);
        console.log("Updated package.json with required dependencies");
      } catch (e) {
        console.log("Could not parse package.json, using fallback");
        pkgFile.content = JSON.stringify(FALLBACK_PACKAGE_JSON, null, 2);
      }
    }

    // STEP 3: Check layout.tsx for broken imports and fix them
    let layoutFile = files.find((f) => f.path === "app/layout.tsx");
    if (!layoutFile) {
      // Create app directory if needed
      if (!fs.existsSync("app")) {
        fs.mkdirSync("app", { recursive: true });
      }
      layoutFile = { path: "app/layout.tsx", content: FALLBACK_LAYOUT };
      files.push(layoutFile);
      console.log("Added fallback app/layout.tsx");
    } else {
      // Check for ALL component imports and verify they exist
      const allImports =
        layoutFile.content.match(
          /import\s+(\w+)\s+from\s+['"](@\/components\/\w+|\.\.?\/components\/\w+)['"]/g,
        ) || [];

      let hasFixedImports = false;

      for (const imp of allImports) {
        // Extract component name and path
        const match = imp.match(
          /import\s+(\w+)\s+from\s+['"](@\/components\/(\w+)|\.\.?\/components\/(\w+))['"]/,
        );
        if (match) {
          const componentName = match[1];
          const componentFileName = match[3] || match[4];

          // Check various possible file paths
          const possiblePaths = [
            `components/${componentFileName}.tsx`,
            `components/${componentFileName}.ts`,
            `components/${componentFileName}.jsx`,
            `components/${componentFileName}.js`,
            `components/${componentFileName}/index.tsx`,
            `components/${componentFileName}/index.ts`,
          ];

          const componentExists = possiblePaths.some((p) =>
            filePathsFound.has(p),
          );

          if (!componentExists) {
            console.log(
              `Warning: layout.tsx imports ${componentName} from components/${componentFileName} but it doesn't exist`,
            );

            // Remove the import line
            layoutFile.content = layoutFile.content.replace(
              new RegExp(
                `import\\s+${componentName}\\s+from\\s+['"][^'"]+['"]\\s*;?\\n?`,
                "g",
              ),
              "",
            );

            // Remove JSX usage - self-closing tags
            layoutFile.content = layoutFile.content.replace(
              new RegExp(`<${componentName}\\s*/>`, "g"),
              "",
            );

            // Remove JSX usage - tags with content
            layoutFile.content = layoutFile.content.replace(
              new RegExp(
                `<${componentName}[^>]*>([\\s\\S]*?)</${componentName}>`,
                "g",
              ),
              "",
            );

            // Remove JSX usage - opening tags (in case of weird formatting)
            layoutFile.content = layoutFile.content.replace(
              new RegExp(`<${componentName}[^/>]*>`, "g"),
              "",
            );
            layoutFile.content = layoutFile.content.replace(
              new RegExp(`</${componentName}>`, "g"),
              "",
            );

            hasFixedImports = true;
            console.log(`Removed broken import and usage for ${componentName}`);
          }
        }
      }

      if (hasFixedImports) {
        // Clean up any extra whitespace/newlines
        layoutFile.content = layoutFile.content
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }
    }

    // STEP 4: Ensure page.tsx exists
    if (!filePathsFound.has("app/page.tsx")) {
      files.push({ path: "app/page.tsx", content: FALLBACK_PAGE });
      console.log("Added fallback app/page.tsx");
    }

    // STEP 5: Ensure globals.css exists
    if (!filePathsFound.has("app/globals.css")) {
      files.push({
        path: "app/globals.css",
        content: ESSENTIAL_FILES["app/globals.css"],
      });
      console.log("Added essential: app/globals.css");
    }

    // STEP 6: Write all AI-generated files (except config files we already wrote)
    console.log("\nWriting", files.length, "AI-generated files...");
    const configFilesToSkip = ["tsconfig.json", "next-env.d.ts"];

    for (const file of files) {
      // Skip config files we already wrote
      if (configFilesToSkip.includes(file.path)) {
        console.log("Skipping (already written):", file.path);
        continue;
      }

      const dir = file.path.split("/").slice(0, -1).join("/");
      if (dir && !fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Sanitize CSS files to remove problematic classes
      let content = file.content;
      if (file.path.endsWith(".css")) {
        content = sanitizeCssContent(content);
      }

      fs.writeFileSync(file.path, content);
      console.log("Created:", file.path);
    }

    // STEP 7: Verify routes - check if all linked routes have corresponding pages
    console.log("\nVerifying routes...");
    const allFileContents = files.map((f) => f.content).join("\n");

    // Find all href="/something" patterns
    const hrefMatches =
      allFileContents.match(/href=["']\/([^"'#?]+)["']/g) || [];
    const linkedRoutes = new Set();

    for (const match of hrefMatches) {
      const routeMatch = match.match(/href=["']\/([^"'#?]+)["']/);
      if (routeMatch && routeMatch[1]) {
        const route = routeMatch[1].split("/")[0]; // Get first segment
        if (route && route !== "") {
          linkedRoutes.add(route);
        }
      }
    }

    // Check if each linked route has a page file
    for (const route of linkedRoutes) {
      const routePagePath = `app/${route}/page.tsx`;
      const routePagePathJs = `app/${route}/page.js`;

      if (
        !filePathsFound.has(routePagePath) &&
        !filePathsFound.has(routePagePathJs)
      ) {
        console.log(
          `Warning: Link to /${route} found but no page exists. Creating placeholder...`,
        );

        // Create a placeholder page for the missing route
        const placeholderPage = `export default function ${route.charAt(0).toUpperCase() + route.slice(1)}Page() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <h1 className="text-4xl font-bold mb-4">${route.charAt(0).toUpperCase() + route.slice(1)}</h1>
      <p className="text-lg text-gray-600">This page is under construction.</p>
      <a href="/" className="mt-4 text-blue-500 hover:underline">← Back to Home</a>
    </main>
  )
}`;

        // Create the directory and file
        const routeDir = `app/${route}`;
        if (!fs.existsSync(routeDir)) {
          fs.mkdirSync(routeDir, { recursive: true });
        }
        fs.writeFileSync(routePagePath, placeholderPage);
        console.log(`Created placeholder: ${routePagePath}`);
      } else {
        console.log(`✓ Route /${route} has a page`);
      }
    }

    console.log("\nGeneration complete!");
    console.log("Total files written:", files.length + 2); // +2 for tsconfig and next-env

    // Write generation log for debugging
    fs.writeFileSync(
      "generation-log.json",
      JSON.stringify(
        {
          prompt: prompt,
          response: content,
          files: files.map((f) => f.path),
        },
        null,
        2,
      ),
    );

    // List all files
    const allFiles = fs.readdirSync(".").filter((f) => !f.startsWith("."));
    console.log("All files:", allFiles.join(", "));

    // Verify critical files exist
    console.log("\nVerifying critical files...");
    const criticalFiles = [
      "package.json",
      "tsconfig.json",
      "next.config.js",
      "tailwind.config.js",
      "postcss.config.js",
      "app/layout.tsx",
      "app/page.tsx",
      "app/globals.css",
    ];

    for (const cf of criticalFiles) {
      if (fs.existsSync(cf)) {
        console.log(`✓ ${cf} exists`);
      } else {
        console.log(`✗ ${cf} MISSING!`);
      }
    }
  } catch (error) {
    console.error("Error:", error.message);
    if (error.response) {
      console.error("Response:", error.response.data);
    }
    process.exit(1);
  }
}

generateWebsite().catch(console.error);
